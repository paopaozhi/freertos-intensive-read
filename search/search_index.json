{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"FreeRTOS\u7cbe\u8bfb","text":"<p>\u8be5\u9879\u76ee\u901a\u8fc7\u5f00\u53d1\u5b9e\u4f8b\u7684\u65b9\u5f0f\u5b66\u4e60FreeRTOS\uff0c\u5bf9\u4e8eFreeRTOS\u7406\u8bba\u901a\u8fc7\u767d\u8bdd\u548c\u56fe\u7247\u65b9\u5f0f\u8fdb\u884c\u8bb2\u89e3\uff0c\u5bf9\u4e8e\u5355\u7247\u673a\u5916\u8bbe\u901a\u8fc7\u5b9e\u4f8b\u7406\u89e3\uff0c\u6587\u5b57\u89e3\u8bf4\uff0c\u56fe\u7247\u89e3\u91ca\u7684\u65b9\u5f0f\u8fdb\u884c\u8bb2\u89e3\u3002</p>"},{"location":"#_1","title":"\u4f9d\u8d56","text":"<p>\u8be5\u9879\u76ee\u4f7f\u7528CLion\u4f5c\u4e3a\u5f00\u53d1IDE\uff0cSTM32Cubx\u4f5c\u4e3a\u5de5\u7a0b\u751f\u6210\u5de5\u5177</p>"},{"location":"#_2","title":"\u9879\u76ee\u8d21\u732e","text":"<ol> <li>\u5411\u4ed3\u5e93\u63d0\u4ea4Pr</li> <li>\u8054\u7cfb\u6211: paopaozhi@hotmail.com</li> </ol>"},{"location":"migrationRTOS/","title":"\u79fb\u690dRTOS\u5230NANO","text":""},{"location":"migrationRTOS/#_1","title":"\u51c6\u5907\u4e00\u4e2a\u5b8c\u6574\u7684\u5de5\u7a0b\u53ef\u4ee5\u6b63\u5e38\u7f16\u8bd1\u4e0b\u8f7d\u7684\u5de5\u7a0b","text":"<p>\u5f85\u65bd\u5de5</p>"},{"location":"migrationRTOS/#_2","title":"\u7ebf\u7a0b\u7ba1\u7406","text":""},{"location":"migrationRTOS/#_3","title":"\u62a2\u5360\u5f0f\u591a\u4efb\u52a1\u7cfb\u7edf","text":"<p>\u591a\u4efb\u52a1\u7cfb\u7edf\u5c31\u662f\u5c06\u4ee5\u524d\u7684\u5927\u4efb\u52a1\u62c6\u5206\u6210\u4e00\u4e2a\u4e00\u4e2a\u4efb\u52a1\u8fd0\u884c\uff0c\u5404\u4e2a\u4efb\u52a1\u901a\u8fc7\u4fe1\u53f7\u91cf\u7b49\u8fdb\u884c\u901a\u4fe1\u3002</p> <p>\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u7ebf\u7a0b\u4efb\u52a1\u6765\u8bf4\uff0c\u5b83\u6c38\u4e0d\u8fd4\u56de\u3002\u8fd9\u6837\u5b50\u5c31\u4fdd\u8bc1\u4e86\u6bcf\u4e00\u4e2a\u4efb\u52a1\u72ec\u7acb\uff0c\u5e76\u4e14\u5bf9\u4e8e\u591a\u4efb\u52a1\u7cfb\u7edf\u6765\u8bf4\u8fd8\u4f1a\u6709\u5173\u4e8e\u4f18\u5148\u7ea7\u7684\u63cf\u8ff0\uff0c\u8fd9\u6837\u5bf9\u4e8e\u6574\u4e2a\u7cfb\u7edf\u6765\u8bf4\u5b9e\u65f6\u6027\u5f97\u5230\u66f4\u5927\u7684\u63d0\u9ad8\u3002</p> <p></p> <ol> <li>\u5b9e\u65f6\u6027</li> <li>\u4fbf\u5229\u6027</li> </ol>"},{"location":"queue/","title":"\u901a\u8fc7\u961f\u5217\u4f20\u9012\u6307\u9488","text":"<p>\u53d1\u9001\u6307\u9488\u65f6\u53d1\u9001\u6307\u9488</p> <pre><code>//\u4f20\u9012\u7ed3\u6784\u4f53\u7684\u6307\u9488\n/* \u521b\u5efa10\u4e2a\u5b58\u50a8\u6307\u9488\u53d8\u91cf\u7684\u6d88\u606f\u961f\u5217\uff0c\u7531\u4e8eCM3/CM4\u5185\u6838\u662f32\u4f4d\u673a\uff0c\u4e00\u4e2a\u6307\u9488\u53d8\u91cf\u5360\u75284\u4e2a\u5b57\u8282 */\nxQueue = xQueueCreate(10, sizeof(struct Msg *));    //\u5355\u5143\u5927\u5c0f\u4e3a\u4e00\u4e2a\u6307\u9488\u53d8\u91cf\u7684\u5927\u5c0f\n\n//\u53d1\u9001\u6d88\u606f\uff0c\u5b9e\u73b0\u7ed3\u6784\u4f53\u6307\u9488\u7684\u4f20\u9012 \nMSG_T *ptMsg;        //MSG_T\u4e3a\u7ed3\u6784\u4f53\u58f0\u660e\nptMsg = &amp;g_tMsg;   /* \u521d\u59cb\u5316\u7ed3\u6784\u4f53\u6307\u9488 */\n// \u521d\u59cb\u5316\u6570\u7ec4 \nptMsg-&gt;ucMessageID = 0;\nptMsg-&gt;ulData[0] = 0;\nptMsg-&gt;usData[0] = 0;\n//\u4f7f\u7528\u6d88\u606f\u961f\u5217\u5b9e\u73b0\u6307\u9488\u53d8\u91cf\u7684\u4f20\u9012 \nif (xQueueSend(xQueue2,                  /* \u6d88\u606f\u961f\u5217\u53e5\u67c4 */\n               (void *) &amp;ptMsg,           // \u53d1\u9001\u7ed3\u6784\u4f53\u6307\u9488\u53d8\u91cfptMsg\u7684\u5730\u5740  \u201c&amp;\u201d  \u53d6\u7ed3\u6784\u4f53\u6307\u9488\u7684\u5730\u5740\uff0c\u4f20\u9012\u6307\u9488\n               (TickType_t) 10) != pdPASS)\n\n//\u63a5\u6536\u6d88\u606f\uff0c\u63a5\u6536\u7ed3\u6784\u4f53\u7684\u6307\u9488\n    MSG_T *ptMsg; //\u5b9a\u4e49\u4e00\u4e2a\u7ed3\u6784\u4f53\u6307\u9488\nxResult = xQueueReceive(xQueue2,            /* \u6d88\u606f\u961f\u5217\u53e5\u67c4 */\n                        (void *) &amp;ptMsg,      // \u8fd9\u91cc\u83b7\u53d6\u7684\u662f\u7ed3\u6784\u4f53\u7684\u5730\u5740,\u7c7b\u4f3c\u4e8e char *a=\"stm\";char *b;b=a \u6307\u9488\u8d4b\u503c\uff0ca\u548cb\u6307\u5411\u540c\u4e00\u4e2a\u5730\u5740\n                        (TickType_t) xMaxBlockTime);/* \u8bbe\u7f6e\u963b\u585e\u65f6\u95f4 */\nif (xResult == pdPASS) {\n    /* \u6210\u529f\u63a5\u6536\uff0c\u5e76\u901a\u8fc7\u4e32\u53e3\u5c06\u6570\u636e\u6253\u5370\u51fa\u6765 */\n    printf(\"\u63a5\u6536\u5230\u6d88\u606f\u961f\u5217\u6570\u636eptMsg-&gt;ucMessageID = %d\\r\\n\", ptMsg-&gt;ucMessageID);\n    printf(\"\u63a5\u6536\u5230\u6d88\u606f\u961f\u5217\u6570\u636eptMsg-&gt;ulData[0] = %d\\r\\n\", ptMsg-&gt;ulData[0]);\n    printf(\"\u63a5\u6536\u5230\u6d88\u606f\u961f\u5217\u6570\u636eptMsg-&gt;usData[0] = %d\\r\\n\", ptMsg-&gt;usData[0]);\n} \n</code></pre>"},{"location":"rtc_ledsmg/","title":"\u6570\u7801\u7ba1\u5b9e\u65f6\u65f6\u949f\u663e\u793a","text":"RTC"},{"location":"rtc_ledsmg/#rtc","title":"\u6dfb\u52a0RTC\u652f\u6301","text":""},{"location":"rtc_ledsmg/#rtc_1","title":"\u521d\u59cb\u5316RTC\u5916\u8bbe","text":"<p>\u521b\u5efa<code>rtc.c</code> <code>rtc.h</code> \u6587\u4ef6</p>"},{"location":"rtc_ledsmg/#api","title":"API\u51fd\u6570","text":"<p>RTC\u65f6\u949f\u521d\u59cb\u5316: <code>HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)</code></p> <p>RTC\u65f6\u949f\u65f6\u95f4\u8bbe\u7f6e: <code>HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</code></p> <p>RTC\u65e5\u671f\u8bbe\u7f6e: <code>HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</code></p> <pre><code>// RTC\u521d\u59cb\u5316\nvoid MX_RTC_Init(void) {\n    RTC_TimeTypeDef sTime = {0};\n    RTC_DateTypeDef DateToUpdate = {0};\n\n    hrtc.Instance = RTC;\n    hrtc.Init.AsynchPrediv = 32767;\n\n    HAL_RTC_Init(&amp;hrtc);\n\n    sTime.Hours = 0x0;\n    sTime.Minutes = 0x0;\n    sTime.Seconds = 0x0;\n\n    HAL_RTC_SetTime(&amp;hrtc, &amp;sTime, RTC_FORMAT_BCD);\n\n    // 2023 11 10 \u4e94\n    DateToUpdate.Year = 0x23;\n    DateToUpdate.Month = RTC_MONTH_NOVEMBER;\n    DateToUpdate.Date = 0x10;\n    DateToUpdate.WeekDay = RTC_WEEKDAY_FRIDAY;\n\n    HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BCD);\n}\n\n// RTC msp init\nvoid HAL_RTC_MspInit(RTC_HandleTypeDef *rtcHandle) {\n\n    if (rtcHandle-&gt;Instance == RTC) {\n    /* USER CODE BEGIN RTC_MspInit 0 */\n\n    /* USER CODE END RTC_MspInit 0 */\n    HAL_PWR_EnableBkUpAccess();\n    /* Enable BKP CLK enable for backup registers */\n    __HAL_RCC_BKP_CLK_ENABLE();\n    /* RTC clock enable */\n    __HAL_RCC_RTC_ENABLE();\n    /* USER CODE BEGIN RTC_MspInit 1 */\n\n    /* USER CODE END RTC_MspInit 1 */\n    }\n}\n</code></pre>"},{"location":"rtc_ledsmg/#rtc-demo","title":"RTC demo","text":"<p><code>rtc.c</code> <pre><code>void MX_RTC_Init(void) {\n    RTC_TimeTypeDef sTime = {0};\n    RTC_DateTypeDef DateToUpdate = {0};\n\n    hrtc.Instance = RTC;\n    hrtc.Init.AsynchPrediv = 32767;\n\n    HAL_RTC_Init(&amp;hrtc);\n\n    // 00:00:00\n    sTime.Hours = 0x0;\n    sTime.Minutes = 0x0;\n    sTime.Seconds = 0x0;\n\n    HAL_RTC_SetTime(&amp;hrtc, &amp;sTime, RTC_FORMAT_BCD);\n\n    // 2023 11 10 \u4e94\n    DateToUpdate.Year = 0x23;\n    DateToUpdate.Month = RTC_MONTH_NOVEMBER;\n    DateToUpdate.Date = 0x10;\n    DateToUpdate.WeekDay = RTC_WEEKDAY_FRIDAY;\n\n    HAL_RTC_SetDate(&amp;hrtc, &amp;DateToUpdate, RTC_FORMAT_BCD);\n}\n\n// RTC msp init\nvoid HAL_RTC_MspInit(RTC_HandleTypeDef *rtcHandle) {\n\n    if (rtcHandle-&gt;Instance == RTC) {\n    /* USER CODE BEGIN RTC_MspInit 0 */\n\n    /* USER CODE END RTC_MspInit 0 */\n    HAL_PWR_EnableBkUpAccess();\n    /* Enable BKP CLK enable for backup registers */\n    __HAL_RCC_BKP_CLK_ENABLE();\n    /* RTC clock enable */\n    __HAL_RCC_RTC_ENABLE();\n    /* USER CODE BEGIN RTC_MspInit 1 */\n\n    /* USER CODE END RTC_MspInit 1 */\n    }\n}\n</code></pre></p> <p><code>main.c</code></p> <pre><code>#include &lt;stdio.h&gt;\n#include \"stm32f1xx_hal.h\"\n#include \"rtc.h\"\n\nuint8_t sShowTime[40];\nuint8_t sShowData[40];\n\nUART_HandleTypeDef huart1;\n\nvoid MX_USART1_UART_Init(void) {\n  huart1.Instance = USART1;\n  huart1.Init.BaudRate = 115200;\n  huart1.Init.WordLength = UART_WORDLENGTH_8B;\n  huart1.Init.StopBits = UART_STOPBITS_1;\n  huart1.Init.Parity = UART_PARITY_NONE;\n  huart1.Init.Mode = UART_MODE_TX_RX;\n  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;\n  huart1.Init.OverSampling = UART_OVERSAMPLING_16;\n  HAL_UART_Init(&amp;huart1);\n}\n\nvoid HAL_UART_MspInit(UART_HandleTypeDef* uartHandle) {\n\n  GPIO_InitTypeDef GPIO_InitStruct = {0};\n  if(uartHandle-&gt;Instance==USART1)\n  {\n    __HAL_RCC_USART1_CLK_ENABLE();\n\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n\n    GPIO_InitStruct.Pin = GPIO_PIN_9;\n    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\n    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;\n    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);\n\n    GPIO_InitStruct.Pin = GPIO_PIN_10;\n    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;\n    GPIO_InitStruct.Pull = GPIO_NOPULL;\n    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);\n\n  }\n}\n\n\n\nvoid main {\n    MX_USART1_UART_Init();\n    MX_RTC_Init();\n\n    while(1){\n        RTC_TimeShow(sShowTime);\n        RTC_DataShow(sShowData);\n        printf(\"data:%s time: %s\\r\\n\",sShowData,sShowTime);\n        HAL_Delay(1000);\n    }\n};\n\nint _write(int fd, char *ptr, int len) {\n    HAL_UART_Transmit(&amp;huart1, (uint8_t*)ptr, len, 0xFFFF);\n    return len;\n}\n</code></pre> <p>\u5b9e\u9a8c\u73b0\u8c61\uff1a</p>"},{"location":"usb_study/","title":"USB\u5b66\u4e60","text":""},{"location":"usb_study/#stm32f1usbcdc","title":"\u6d4b\u8bd5STM32F1USB(CDC)","text":"<p>\u4f7f\u7528stm32cubx\u751f\u6210\u6d4b\u8bd5demo</p> <ul> <li>\u57fa\u7840\u8bbe\u7f6e\u8bf7\u53c2\u8003\u57fa\u7840\u914d\u7f6e</li> </ul> <p></p> <p></p> <p></p>"},{"location":"usb_study/#usb_1","title":"usb\u53d1\u9001\u6570\u636e\u5230\u4e0a\u4f4d\u673a","text":"<p>\u901a\u8fc7<code>usbd_cdc_if.c</code>\u4e2d\u7684<code>CDC_Transmit_FS</code></p> <pre><code>uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)\n{\n  uint8_t result = USBD_OK;\n  /* USER CODE BEGIN 7 */\n  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;\n  if (hcdc-&gt;TxState != 0){\n    return USBD_BUSY;\n  }\n  USBD_CDC_SetTxBuffer(&amp;hUsbDeviceFS, Buf, Len);\n  result = USBD_CDC_TransmitPacket(&amp;hUsbDeviceFS);\n  /* USER CODE END 7 */\n  return result;\n}\n</code></pre> <p>\u5728<code>main.c</code>\u4e2d\u7f16\u5199\u4ee3\u7801,\u53d1\u9001<code>Hello USB_CDC</code>\u5230\u4e0a\u4f4d\u673a</p> <pre><code>int main(void){\n    // \u7701\u7565cubx\u751f\u6210\u7684\u521d\u59cb\u5316\u4ee3\u7801\n    uint8_t buf[] = \"Hello USB_CDC\\r\\n\";\n    while(1){\n        CDC_Transmit_FS(buf,sizeof(buf));\n        HAL_Delay(1000);\n    }\n}\n</code></pre>"},{"location":"usb_study/#stm32cubx","title":"\u5b89\u88c5stm32cubx\u865a\u62df\u4e32\u53e3\u9a71\u52a8","text":"<p>https://www.st.com/zh/development-tools/stsw-stm32102.html</p> <p>\u6839\u636e\u81ea\u8eab\u7535\u8111\u7684\u67b6\u6784\u9009\u62e9\u5408\u9002\u7684\u9a71\u52a8,\u9a71\u52a8\u7248\u672c\u5efa\u8bae\u9009\u62e9W8</p> <p></p>"},{"location":"usb_study/#_1","title":"\u9a8c\u8bc1\u5f00\u53d1","text":"<p>\u6253\u5f00\u4e32\u53e3\u8c03\u8bd5\u52a9\u624b,\u9009\u62e9\u5bf9\u5e94\u7684\u4e32\u53e3\u53f7,\u6ce2\u7279\u7387\u968f\u610f\u9009\u62e9\u4e0d\u5f71\u54cd\u5b9e\u9a8c\u6548\u679c</p> <p></p>"},{"location":"usb_study/#usb_2","title":"\u521d\u6b65\u4e86\u89e3USB","text":""},{"location":"usb_study/#stm-usblib","title":"\u63a2\u7a76STM-USBLib","text":""},{"location":"usb_study/#usb_3","title":"USB\u521d\u59cb\u5316\u6d41\u7a0b","text":"<p>\u53c2\u8003\u94fe\u63a5 https://blog.csdn.net/jimaofu0494/article/details/109233087</p>"}]}